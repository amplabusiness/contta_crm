# Documentação Técnica: Backend do Contta CRM

Este documento descreve a arquitetura e os passos para construir o backend do Contta CRM, utilizando Supabase como Backend-as-a-Service (BaaS) e Vercel para a hospedagem do frontend e das APIs serverless.

## 1. Visão Geral e Arquitetura

A arquitetura proposta é moderna, escalável e de baixo custo inicial, ideal para um projeto em crescimento.

-   **Frontend**: A aplicação React existente.
-   **Hosting e API**: Vercel será usada para hospedar o frontend e para executar nossa lógica de backend como Funções Serverless (API Routes).
-   **Banco de Dados e Autenticação**: Supabase fornecerá um banco de dados PostgreSQL, sistema de autenticação, e APIs de banco de dados auto-geradas.

**Fluxo de Dados:**

```
[Usuário no Navegador] -> [Frontend React (Vercel)] -> [API Routes (Vercel)] -> [Supabase (PostgreSQL/Auth)]
```

-   O frontend se comunica com as API Routes que criaremos.
-   As API Routes contêm a lógica de negócio e se comunicam com o Supabase para acessar o banco de dados de forma segura.
-   O frontend também pode se comunicar diretamente com o Supabase para operações de autenticação (login, logout).

## 2. Tecnologias

-   **Linguagem**: TypeScript (Frontend e Backend)
-   **Framework Frontend**: React 19
-   **Plataforma de Backend**: Vercel Serverless Functions (Node.js)
-   **Banco de Dados**: Supabase (PostgreSQL)
-   **Autenticação**: Supabase Auth
-   **Cliente Supabase**: `@supabase/supabase-js`

## 3. Configuração do Supabase

### Passo 1: Criar o Projeto

1.  Acesse [supabase.com](https://supabase.com) e crie um novo projeto.
2.  Guarde a **URL do Projeto** e a chave de API **`anon (public)`**. Elas serão usadas no frontend.
3.  Guarde a chave de API **`service_role (secret)`**. Ela será usada nas API Routes da Vercel para operações com privilégios de administrador.

### Passo 2: Desenho do Banco de Dados

Acesse o "SQL Editor" no painel do Supabase e execute os seguintes comandos SQL para criar as tabelas. Este esquema é baseado nos tipos definidos em `types.ts`.

```sql
-- Enum Types para simular os tipos do TypeScript
CREATE TYPE public."UserRole" AS ENUM ('Admin', 'User');
CREATE TYPE public."DealStage" AS ENUM ('Prospecting', 'Qualification', 'Proposal', 'Negotiation', 'Closed Won', 'Closed Lost');
CREATE TYPE public."TaskStatus" AS ENUM ('A Fazer', 'Em Andamento', 'Concluída');
CREATE TYPE public."TaskPriority" AS ENUM ('Alta', 'Média', 'Baixa');

-- Tabela de Perfis, ligada à autenticação do Supabase
CREATE TABLE public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  name TEXT,
  email TEXT UNIQUE,
  role public."UserRole" DEFAULT 'User'::"UserRole",
  status TEXT DEFAULT 'Ativo'
);

-- Tabela de Empresas (Prospects/Clientes)
CREATE TABLE public.empresas (
  cnpj TEXT PRIMARY KEY,
  razao_social TEXT NOT NULL,
  nome_fantasia TEXT,
  situacao_cadastral TEXT,
  data_abertura DATE,
  porte TEXT,
  logradouro TEXT,
  numero TEXT,
  bairro TEXT,
  cidade TEXT,
  uf TEXT,
  cep TEXT,
  latitude DOUBLE PRECISION,
  longitude DOUBLE PRECISION,
  cnae_principal_codigo TEXT,
  cnae_principal_descricao TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tabela de Sócios (para evitar duplicatas)
CREATE TABLE public.socios (
  cpf_parcial TEXT PRIMARY KEY, -- Usar um ID único seria melhor, mas seguimos o type
  nome_socio TEXT NOT NULL
);

-- Tabela de Junção para relação Empresa <-> Sócio (Muitos para Muitos)
CREATE TABLE public.empresa_socios (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  empresa_cnpj TEXT REFERENCES public.empresas(cnpj) ON DELETE CASCADE,
  socio_cpf_parcial TEXT REFERENCES public.socios(cpf_parcial) ON DELETE CASCADE,
  qualificacao TEXT,
  percentual_capital NUMERIC,
  UNIQUE(empresa_cnpj, socio_cpf_parcial)
);

-- Tabela de Negócios (Deals)
CREATE TABLE public.deals (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  company_name TEXT NOT NULL,
  value NUMERIC NOT NULL,
  stage public."DealStage" NOT NULL,
  expected_close_date DATE,
  last_activity TIMESTAMPTZ DEFAULT NOW(),
  empresa_cnpj TEXT REFERENCES public.empresas(cnpj) ON DELETE SET NULL,
  owner_id UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tabela de Tarefas
CREATE TABLE public.tasks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  title TEXT NOT NULL,
  due_date DATE,
  priority public."TaskPriority" NOT NULL,
  status public."TaskStatus" NOT NULL,
  description TEXT,
  google_calendar_event_id TEXT,
  deal_id UUID REFERENCES public.deals(id) ON DELETE CASCADE,
  assignee_id UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

### Passo 3: Segurança com Row Level Security (RLS)

A RLS é fundamental para a segurança. Ela garante que os usuários só possam acessar os dados que lhes são permitidos.

1.  Acesse "Authentication" -> "Policies" no Supabase.
2.  Para cada tabela, ative a "Row Level Security".
3.  Crie políticas. Exemplos:

**Política para `profiles` (Usuários podem ver todos os perfis, mas só alterar o seu):**

```sql
-- Permitir leitura de todos os perfis para usuários autenticados
CREATE POLICY "Allow authenticated read access"
ON public.profiles FOR SELECT
USING (auth.role() = 'authenticated');

-- Permitir que usuários atualizem seu próprio perfil
CREATE POLICY "Allow individual update access"
ON public.profiles FOR UPDATE
USING (auth.uid() = id);
```

**Política para `tasks` (Usuários só podem ver e manipular suas próprias tarefas):**

```sql
-- Ativar RLS na tabela de tarefas
ALTER TABLE public.tasks ENABLE ROW LEVEL SECURITY;

-- Permitir CRUD completo para o dono da tarefa
CREATE POLICY "Allow full access for owners"
ON public.tasks FOR ALL
USING (auth.uid() = assignee_id)
WITH CHECK (auth.uid() = assignee_id);
```

**Crie políticas semelhantes para `deals` e outras tabelas conforme a regra de negócio.**

## 4. Backend com Vercel Serverless Functions

As funções serverless são arquivos TypeScript/JavaScript que ficam em um diretório `/api` na raiz do seu projeto. A Vercel automaticamente os transforma em endpoints de API.

### Passo 1: Estrutura do Projeto

```
/
├── api/
│   ├── deals.ts        # Endpoint GET /api/deals
│   └── tasks.ts        # Endpoint GET, POST /api/tasks
├── components/
├── services/
├── index.html
├── index.tsx
└── package.json
```

### Passo 2: Instalar Dependências

```bash
npm install @supabase/supabase-js
```

### Passo 3: Criar um Endpoint de Exemplo (`/api/deals.ts`)

Este arquivo buscará todos os negócios no banco de dados.

```typescript
// /api/deals.ts
import { createClient } from '@supabase/supabase-js';
import type { VercelRequest, VercelResponse } from '@vercel/node';

// Crie o cliente Supabase com a chave de SERVIÇO (secreta)
// É crucial usar variáveis de ambiente na Vercel para segurança
const supabase = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_KEY!
);

export default async function handler(
  request: VercelRequest,
  response: VercelResponse,
) {
  try {
    const { data, error } = await supabase
      .from('deals')
      .select('*')
      .order('created_at', { ascending: false });

    if (error) {
      throw error;
    }

    response.status(200).json(data);
  } catch (error: any) {
    response.status(500).json({ message: error.message });
  }
}
```

### Passo 4: Lista de Rotas da API a Serem Criadas

Baseado no `services/apiService.ts`, você precisará criar os seguintes endpoints:

-   `GET /api/dashboard-data`: Agrega dados de `deals`, `tasks` etc.
-   `GET /api/prospects`: Busca dados de empresas.
-   `GET /api/analytics-data`: Endpoint para gerar relatórios, pode chamar a Gemini API a partir daqui.
-   `GET /api/deals`: Retorna todos os negócios.
-   `GET /api/tasks`, `POST /api/tasks`, `PATCH /api/tasks/[id]`: CRUD para tarefas.
-   `GET /api/team`: Retorna dados da tabela `profiles`.
-   ... e assim por diante para cada entidade do CRM.

## 5. Integração com o Frontend

### Passo 1: Configurar Cliente Supabase no Frontend

Crie um arquivo para inicializar o Supabase no lado do cliente.

```typescript
// /services/supabaseClient.ts
import { createClient } from '@supabase/supabase-js';

// Use as chaves PÚBLICAS aqui
const supabaseUrl = process.env.REACT_APP_SUPABASE_URL!;
const supabaseAnonKey = process.env.REACT_APP_SUPABASE_ANON_KEY!;

export const supabase = createClient(supabaseUrl, supabaseAnonKey);
```

### Passo 2: Modificar os Serviços de API

Atualize o `services/apiService.ts` para chamar os novos endpoints em vez de usar dados mockados.

**Exemplo: Atualizando `fetchDeals`**

```typescript
// /services/apiService.ts

// ... outras importações
import { Deal } from './types.ts';

// Nova função (chamando a API)
export const fetchDeals = async (): Promise<Deal[]> => {
    const response = await fetch('/api/deals');
    if (!response.ok) {
        throw new Error('Falha ao buscar negócios da API.');
    }
    const deals: Deal[] = await response.json();
    return deals;
};
```

### Passo 3: Implementar Autenticação no Frontend

Use o cliente Supabase para gerenciar a autenticação. É recomendado criar um Contexto React para gerenciar o estado do usuário.

**Exemplo de componente de Login:**

```tsx
// /components/Login.tsx
import React, { useState } from 'react';
import { supabase } from '../services/supabaseClient.ts';

const Login: React.FC = () => {
    const [email, setEmail] = useState('');
    const [loading, setLoading] = useState(false);

    const handleLogin = async (e: React.FormEvent) => {
        e.preventDefault();
        setLoading(true);
        const { error } = await supabase.auth.signInWithOtp({ email });
        if (error) {
            alert(error.message);
        } else {
            alert('Verifique seu e-mail para o link de login!');
        }
        setLoading(false);
    };
    
    // ... renderiza o formulário de login
}
```

No componente principal `App.tsx`, você pode ouvir as mudanças de estado da autenticação para redirecionar o usuário.

```tsx
// /App.tsx
import { supabase } from './services/supabaseClient.ts';

useEffect(() => {
    const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) => {
        // Lógica para atualizar o estado do usuário na aplicação
        console.log('Sessão:', session);
    });

    return () => subscription.unsubscribe();
}, []);
```

Com este guia, você tem um plano claro e detalhado para construir um backend robusto e moderno para o Contta CRM.
