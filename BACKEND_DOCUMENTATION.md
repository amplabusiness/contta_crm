# Documentação Técnica: Backend do Contta CRM

Este documento descreve a arquitetura e os passos para construir o backend do Contta CRM, utilizando Supabase como Backend-as-a-Service (BaaS) e Vercel para a hospedagem do frontend e das APIs serverless.

## 1. Visão Geral e Arquitetura

A arquitetura proposta é moderna, escalável e de baixo custo inicial, ideal para um projeto em crescimento.

-   **Frontend**: A aplicação React existente.
-   **Hosting e API**: Vercel será usada para hospedar o frontend e para executar nossa lógica de backend como Funções Serverless (API Routes).
-   **Banco de Dados e Autenticação**: Supabase fornecerá um banco de dados PostgreSQL, sistema de autenticação, e APIs de banco de dados auto-geradas.

**Fluxo de Dados:**

```
[Usuário no Navegador] -> [Frontend React (Vercel)] -> [API Routes (Vercel)] -> [Supabase (PostgreSQL/Auth)]
```

-   O frontend se comunica com as API Routes que criaremos.
-   As API Routes contêm a lógica de negócio e se comunicam com o Supabase para acessar o banco de dados de forma segura.
-   O frontend também pode se comunicar diretamente com o Supabase para operações de autenticação (login, logout).

## 2. Tecnologias

-   **Linguagem**: TypeScript (Frontend e Backend)
-   **Framework Frontend**: React 19
-   **Plataforma de Backend**: Vercel Serverless Functions (Node.js)
-   **Banco de Dados**: Supabase (PostgreSQL)
-   **Autenticação**: Supabase Auth
-   **Cliente Supabase**: `@supabase/supabase-js`

## 3. Configuração do Supabase

### Passo 1: Criar o Projeto

1.  Acesse [supabase.com](https://supabase.com) e crie um novo projeto.
2.  Guarde a **URL do Projeto** e a chave de API **`anon (public)`**. Elas serão usadas no frontend.
3.  Guarde a chave de API **`service_role (secret)`**. Ela será usada nas API Routes da Vercel para operações com privilégios de administrador.

### Passo 2: Desenho do Banco de Dados

Acesse o "SQL Editor" no painel do Supabase e execute os seguintes comandos SQL para criar as tabelas. Este esquema é baseado nos tipos definidos em `types.ts`.

```sql
-- Enum Types para simular os tipos do TypeScript
CREATE TYPE public."UserRole" AS ENUM ('Admin', 'User');
CREATE TYPE public."DealStage" AS ENUM ('Prospecting', 'Qualification', 'Proposal', 'Negotiation', 'Closed Won', 'Closed Lost');
CREATE TYPE public."TaskStatus" AS ENUM ('A Fazer', 'Em Andamento', 'Concluída');
CREATE TYPE public."TaskPriority" AS ENUM ('Alta', 'Média', 'Baixa');

-- Tabela de Perfis, ligada à autenticação do Supabase
CREATE TABLE public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  name TEXT,
  email TEXT UNIQUE,
  role public."UserRole" DEFAULT 'User'::"UserRole",
  status TEXT DEFAULT 'Ativo'
);

-- Tabela de Empresas (Prospects/Clientes)
CREATE TABLE public.empresas (
  cnpj TEXT PRIMARY KEY,
  razao_social TEXT NOT NULL,
  nome_fantasia TEXT,
  situacao_cadastral TEXT,
  data_abertura DATE,
  porte TEXT,
  logradouro TEXT,
  numero TEXT,
  bairro TEXT,
  cidade TEXT,
  uf TEXT,
  cep TEXT,
  latitude DOUBLE PRECISION,
  longitude DOUBLE PRECISION,
  cnae_principal_codigo TEXT,
  cnae_principal_descricao TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tabela de Sócios (para evitar duplicatas)
CREATE TABLE public.socios (
  cpf_parcial TEXT PRIMARY KEY, -- Usar um ID único seria melhor, mas seguimos o type
  nome_socio TEXT NOT NULL
);

-- Tabela de Junção para relação Empresa <-> Sócio (Muitos para Muitos)
CREATE TABLE public.empresa_socios (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  empresa_cnpj TEXT REFERENCES public.empresas(cnpj) ON DELETE CASCADE,
  socio_cpf_parcial TEXT REFERENCES public.socios(cpf_parcial) ON DELETE CASCADE,
  qualificacao TEXT,
  percentual_capital NUMERIC,
  UNIQUE(empresa_cnpj, socio_cpf_parcial)
);

-- Tabela de Negócios (Deals)
CREATE TABLE public.deals (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  company_name TEXT NOT NULL,
  value NUMERIC NOT NULL,
  stage public."DealStage" NOT NULL,
  expected_close_date DATE,
  last_activity TIMESTAMPTZ DEFAULT NOW(),
  empresa_cnpj TEXT REFERENCES public.empresas(cnpj) ON DELETE SET NULL,
  owner_id UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tabela de Tarefas
CREATE TABLE public.tasks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  title TEXT NOT NULL,
  due_date DATE,
  priority public."TaskPriority" NOT NULL,
  status public."TaskStatus" NOT NULL,
  description TEXT,
  google_calendar_event_id TEXT,
  deal_id UUID REFERENCES public.deals(id) ON DELETE CASCADE,
  assignee_id UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

### Passo 3: Segurança com Row Level Security (RLS)

A RLS é fundamental para a segurança. Ela garante que os usuários só possam acessar os dados que lhes são permitidos.

1.  Acesse "Authentication" -> "Policies" no Supabase.
2.  Para cada tabela, ative a "Row Level Security".
3.  Crie políticas. Exemplos:

**Política para `profiles` (Usuários podem ver todos os perfis, mas só alterar o seu):**

```sql
-- Permitir leitura de todos os perfis para usuários autenticados
CREATE POLICY "Allow authenticated read access"
ON public.profiles FOR SELECT
USING (auth.role() = 'authenticated');

-- Permitir que usuários atualizem seu próprio perfil
CREATE POLICY "Allow individual update access"
ON public.profiles FOR UPDATE
USING (auth.uid() = id);
```

**Política para `tasks` (Usuários só podem ver e manipular suas próprias tarefas):**

```sql
-- Ativar RLS na tabela de tarefas
ALTER TABLE public.tasks ENABLE ROW LEVEL SECURITY;

-- Permitir CRUD completo para o dono da tarefa
CREATE POLICY "Allow full access for owners"
ON public.tasks FOR ALL
USING (auth.uid() = assignee_id)
WITH CHECK (auth.uid() = assignee_id);
```

**Crie políticas semelhantes para `deals` e outras tabelas conforme a regra de negócio.**

### Passo 4: Provisionar usuário mestre (Admin)

Para administrar o CRM no Supabase, provisionamos um usuário mestre que recebe permissão `Admin` no metadata e credenciais definidas pelo time. Utilize o script `scripts/create-master-user.js`, que reaproveita as variáveis do projeto e faz upsert (atualiza se já existir).

1. Defina a senha de forma temporária via variável de ambiente (no PowerShell, sessão atual):

  ```powershell
  $env:MASTER_USER_PASSWORD = '@Ampla123'
  $env:MASTER_USER_EMAIL = 'sergio@amplabusiness.com.br'    # opcional, já é o padrão do script
  $env:MASTER_USER_NAME = 'Sergio Carneiro Leao'            # opcional
  $env:MASTER_USER_ROLE = 'Admin'                          # opcional
  $env:MASTER_USER_ORG = 'Ampla Contabilidade'             # opcional
  ```

  > **Importante:** evite commitar senhas em arquivos. Use variáveis efêmeras ou o gerenciador de segredos da Vercel/Supabase.

2. Execute o script:

  ```bash
  node scripts/create-master-user.js
  ```

  Ele validará a sessão com a `SUPABASE_SERVICE_KEY`, criará o usuário caso não exista ou atualizará senha e metadados se já houver registro.

3. Verifique no painel do Supabase em `Authentication → Users` se o usuário está com `role = Admin` no metadata.

### Passo 5: QA das políticas de segurança (RLS)

Para garantir que as políticas RLS continuem válidas após alterações, execute o script de QA dedicado:

```bash
npm run qa:rls
```

O script `scripts/qa-rls.js` provisiona usuários de teste, cria fixtures de negócios/tarefas e valida:

- Usuário padrão **não** consegue alterar registros pertencentes a terceiros.
- Usuário padrão consegue editar seus próprios deals/tarefas/perfil.
- Usuário Admin consegue operar sobre registros de outros usuários.

Todos os dados criados são removidos ao final da execução. Ajuste as variáveis de ambiente (`SUPABASE_URL`, `SUPABASE_SERVICE_KEY`, `VITE_SUPABASE_ANON_KEY`) antes de rodar o QA localmente ou em pipelines.

### Passo 6: Auditoria via MCP

Após qualquer modificação em políticas RLS ou dados sensíveis, registre o evento usando o fluxo do Model Context Protocol descrito em `MCP_AUDITORIA.md`. O resumo do processo é:

- Abrir uma sessão MCP (`npx mcp shell`).
- Executar a alteração necessária.
- Chamar `filesystem.appendFile` para gravar a entrada NDJSON em `logs/audit-log.ndjson` com `timestamp`, `actor`, `scope`, `action`, `description` e `metadata`.
- Encerrar a sessão após confirmar a resposta `{"status":"ok"}` e manter os arquivos de log versionados.

O documento `MCP_AUDITORIA.md` contém exemplos completos de comandos PowerShell e boas práticas de auditoria.

### Passo 7: Seeds e dados de teste

Para popular o ambiente com dados de demonstração, utilize o script `scripts/seed-demo-data.js`:

```bash
npm run seed:demo            # insere/atualiza empresas, negócios e tarefas [SEED]
npm run seed:demo -- --dry-run  # apenas exibe as ações
npm run seed:demo -- --reset    # remove registros previamente criados
```

Por padrão o script associa os registros ao usuário `sergio@amplabusiness.com.br`. Defina `SEED_OWNER_EMAIL` se desejar outro responsável. Certifique-se de ter criado esse usuário previamente (via `scripts/create-master-user.js`) para evitar falhas de FK. As empresas, deals e tarefas inseridos carregam o sufixo `[SEED]`, facilitando sua identificação e limpeza.

### Passo 8: Execução local com `vercel dev`

Com o projeto já `vercel link`ado e as variáveis sincronizadas, basta rodar:

```bash
npx vercel dev --yes
```

O CLI reutiliza as configurações exportadas e inicia o frontend + rotas serverless localmente (porta 3000 por padrão). Caso a porta esteja ocupada, o Vercel CLI informa e escolhe a próxima disponível (`--port 3001`, por exemplo). Encerre com `CTRL+C` e, se necessário, finalize processos residuais via `Stop-Process -Name node` (PowerShell) antes de reiniciar.

## 4. Backend com Vercel Serverless Functions

As funções serverless são arquivos TypeScript/JavaScript que ficam em um diretório `/api` na raiz do seu projeto. A Vercel automaticamente os transforma em endpoints de API.

### Passo 1: Estrutura do Projeto

```
/
├── api/
│   ├── deals.ts        # Endpoint GET /api/deals
│   └── tasks.ts        # Endpoint GET, POST /api/tasks
├── components/
├── services/
├── index.html
├── index.tsx
└── package.json
```

### Passo 2: Instalar Dependências

```bash
npm install @supabase/supabase-js
```

### Passo 3: Criar um Endpoint de Exemplo (`/api/deals.ts`)

Este arquivo buscará todos os negócios no banco de dados.

```typescript
// /api/deals.ts
import { createClient } from '@supabase/supabase-js';
import type { VercelRequest, VercelResponse } from '@vercel/node';

// Crie o cliente Supabase com a chave de SERVIÇO (secreta)
// É crucial usar variáveis de ambiente na Vercel para segurança
const supabase = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_KEY!
);

export default async function handler(
  request: VercelRequest,
  response: VercelResponse,
) {
  try {
    const { data, error } = await supabase
      .from('deals')
      .select('*')
      .order('created_at', { ascending: false });

    if (error) {
      throw error;
    }

    response.status(200).json(data);
  } catch (error: any) {
    response.status(500).json({ message: error.message });
  }
}
```

### Passo 4: Lista de Rotas da API a Serem Criadas

Baseado no `services/apiService.ts`, você precisará criar os seguintes endpoints:

-   `GET /api/dashboard-data`: Agrega dados de `deals`, `tasks` etc.
-   `GET /api/prospects`: Busca dados de empresas.
-   `GET /api/analytics-data`: Endpoint para gerar relatórios, pode chamar a Gemini API a partir daqui.
-   `GET /api/deals`: Retorna todos os negócios.
-   `GET /api/tasks`, `POST /api/tasks`, `PATCH /api/tasks/[id]`: CRUD para tarefas.
-   `GET /api/team`: Retorna dados da tabela `profiles`.
-   ... e assim por diante para cada entidade do CRM.

## 5. Integração com o Frontend

### Passo 1: Configurar Cliente Supabase no Frontend

Crie um arquivo para inicializar o Supabase no lado do cliente.

```typescript
// /services/supabaseClient.ts
import { createClient } from '@supabase/supabase-js';

// Use as chaves PÚBLICAS aqui
const supabaseUrl = process.env.REACT_APP_SUPABASE_URL!;
const supabaseAnonKey = process.env.REACT_APP_SUPABASE_ANON_KEY!;

export const supabase = createClient(supabaseUrl, supabaseAnonKey);
```

### Passo 2: Modificar os Serviços de API

Atualize o `services/apiService.ts` para chamar os novos endpoints em vez de usar dados mockados.

**Exemplo: Atualizando `fetchDeals`**

```typescript
// /services/apiService.ts

// ... outras importações
import { Deal } from './types.ts';

// Nova função (chamando a API)
export const fetchDeals = async (): Promise<Deal[]> => {
    const response = await fetch('/api/deals');
    if (!response.ok) {
        throw new Error('Falha ao buscar negócios da API.');
    }
    const deals: Deal[] = await response.json();
    return deals;
};
```

### Passo 3: Implementar Autenticação no Frontend

Use o cliente Supabase para gerenciar a autenticação. É recomendado criar um Contexto React para gerenciar o estado do usuário.

**Exemplo de componente de Login:**

```tsx
// /components/Login.tsx
import React, { useState } from 'react';
import { supabase } from '../services/supabaseClient.ts';

const Login: React.FC = () => {
    const [email, setEmail] = useState('');
    const [loading, setLoading] = useState(false);

    const handleLogin = async (e: React.FormEvent) => {
        e.preventDefault();
        setLoading(true);
        const { error } = await supabase.auth.signInWithOtp({ email });
        if (error) {
            alert(error.message);
        } else {
            alert('Verifique seu e-mail para o link de login!');
        }
        setLoading(false);
    };
    
    // ... renderiza o formulário de login
}
```

No componente principal `App.tsx`, você pode ouvir as mudanças de estado da autenticação para redirecionar o usuário.

```tsx
// /App.tsx
import { supabase } from './services/supabaseClient.ts';

useEffect(() => {
    const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) => {
        // Lógica para atualizar o estado do usuário na aplicação
        console.log('Sessão:', session);
    });

    return () => subscription.unsubscribe();
}, []);
```

Com este guia, você tem um plano claro e detalhado para construir um backend robusto e moderno para o Contta CRM.

## 6. Documentação dos Endpoints Existentes

### `/api/prospects`

- **Métodos**: `GET`, `POST`, `DELETE`, `OPTIONS`
- **Autenticação**: feita via `SUPABASE_SERVICE_KEY`; rota assume execução em ambiente confiável (Vercel Functions) e expõe CORS liberado (`Access-Control-Allow-Origin: *`).
- **Headers padrão**: Todas as respostas carregam os cabeçalhos definidos em `httpCorsHeaders`, garantindo suporte a clients browser e pré-flight.

#### `GET /api/prospects`

- **Descrição**: Lista empresas prospectadas com suporte a paginação, busca textual (`razao_social`, `nome_fantasia`, `cnpj`) ou filtro direto por CNPJ.
- **Query Params**:
  - `search` (opcional): string livre; caracteres `%` e `_` são sanitizados antes do `ilike` preventivo.
  - `cnpj` (opcional): aceita CNPJ formatado ou somente dígitos; prevalece sobre `search`.
  - `limit` (opcional): inteiro entre 1 e 100 (default 25).
  - `offset` (opcional): inteiro >= 0 (default 0).
- **Resposta 200**: `Array<Prospecto>`, cada item no formato normalizado por `mapEmpresaRecord`:

```json
{
  "cnpj": "01234567000189",
  "razao_social": "Empresa Exemplo LTDA",
  "nome_fantasia": "Exemplo",
  "situacao_cadastral": "Ativa",
  "data_abertura": "2021-05-01",
  "porte": "ME",
  "endereco_principal": {
    "logradouro": "Rua A",
    "numero": "100",
    "bairro": "Centro",
    "cidade": "São Paulo",
    "uf": "SP",
    "cep": "01001000",
    "latitude": -23.55052,
    "longitude": -46.633308
  },
  "cnae_principal": {
    "codigo": "6201500",
    "descricao": "Desenvolvimento de softwares"
  },
  "quadro_socios": [
    {
      "nome_socio": "Fulano de Tal",
      "cpf_parcial": "***123",
      "qualificacao": "Sócio",
      "percentual_capital": 50
    }
  ],
  "telefones": ["11999998888"],
  "emails": ["contato@exemplo.com"],
  "documentos": []
}
```

- **Headers adicionais**: `X-Total-Count` com a contagem total antes da paginação (exposta quando Supabase retorna `count`).
- **Erros comuns**: retorna 500 em falhas do Supabase; 204 vazio quando não há registros.

#### `POST /api/prospects`

- **Descrição**: Cria ou atualiza uma empresa. O handler faz `upsert` com base no CNPJ e sincroniza a tabela de sócios (`socios`/`empresa_socios`).
- **Payload obrigatório**:

```json
{
  "cnpj": "01234567000189",
  "razao_social": "Empresa Exemplo LTDA"
}
```

- **Campos opcionais**: `nome_fantasia`, `situacao_cadastral`, `data_abertura`, `porte`, `endereco_principal` (logradouro, número, bairro, cidade, uf, cep, latitude, longitude), `cnae_principal` (código, descrição), `telefones`, `emails`, `documentos`, `quadro_socios` (lista com `nome_socio`, `cpf_parcial`, `qualificacao`, `percentual_capital`).
- **Normalização interna**: CNPJ recebe `replace(/[^0-9]/g, '')`; campos não enviados viram `null` ou coleções vazias; latitude/longitude passam por `sanitizeNumber` para evitar `NaN`.
- **Resposta 201**: corpo idêntico ao formato do `GET`, refletindo dados persistidos e, se sócios foram enviados, já inclui vínculos atualizados.
- **Erros comuns**:
  - `400`: ausência de `cnpj` ou `razao_social`.
  - `500`: falhas ao persistir dados ou recuperar registro após `upsert`.

#### `DELETE /api/prospects`

- **Descrição**: Remove uma empresa pelo CNPJ e cascata os sócios via FK (`ON DELETE CASCADE` em `empresa_socios`).
- **Query Param obrigatório**: `cnpj` (qualquer formato; é sanitizado para dígitos antes do delete).
- **Resposta 204**: nenhuma carga útil quando a exclusão ocorre sem erros.
- **Erros comuns**:
  - `400`: ausência do parâmetro `cnpj`.
  - `404`: Supabase retorna erro `406` quando não encontra o registro; o handler mapeia para mensagem "Empresa não encontrada.".
  - `500`: falhas inesperadas do Supabase.

#### `OPTIONS /api/prospects`

- Implementado para responder pré-flight CORS com `204 No Content`.

### `/api/deals`

- **Métodos**: `GET`, `POST`, `PATCH`, `DELETE`, `OPTIONS`
- **Autenticação**: obrigatória; usa `requireUser` para validar token Supabase (Bearer em `Authorization` ou cookie `sb-access-token`).
- **Headers padrão**: política CORS aberta e suporte a credenciais.

#### `GET /api/deals`

- **Descrição**: Lista negócios em ordem decrescente de criação, incluindo empresa relacionada (`empresas`) e dono (`profiles`), traduzidos por `mapDealRecord`.
- **Resposta 200**: `Array<Deal>` com campos `id`, `companyName`, `contactName`, `contactEmail`, `value`, `probability`, `expectedCloseDate`, `lastActivity`, `stage` e bloco opcional `health` (`score`, `reasoning`, `suggestedAction`).
- **Erros**: `401` ausência/expiração de token; `500` falhas Supabase.

#### `POST /api/deals`

- **Descrição**: Cria um negócio. Valida `companyName` como string.
- **Payload** (campos opcionais nulos quando omitidos): `contactName`, `contactEmail`, `value`, `probability`, `stage`, `expectedCloseDate`, `empresaCnpj`, `ownerId`.
- **Resposta 201**: registro recém-criado em formato `mapDealRecord`.
- **Erros**: `400` ausência de `companyName`; `401` sem auth; `500` erro Supabase.

#### `PATCH /api/deals?id=<uuid>`

- **Descrição**: Atualiza campos pontuais; apenas propriedades presentes no corpo são mapeadas para colunas SQL.
- **Campos aceitos**: `companyName`, `contactName`, `contactEmail`, `value`, `probability`, `stage`, `expectedCloseDate`, `empresaCnpj`, `ownerId`, `health` (objeto com `score`, `reasoning`, `suggestedAction`).
- **Resposta 200**: negócio atualizado.
- **Erros**: `400` ID ausente ou repetido; `404` negócio inexistente; `401` auth; `500` Supabase.

#### `DELETE /api/deals?id=<uuid>`

- **Descrição**: Remove negócio pelo `id` informado na query.
- **Resposta 204** quando excluído com sucesso.
- **Erros**: `400` ID inválido; `404` negócio não encontrado; `401` auth.

### `/api/tasks`

- **Métodos**: `GET`, `POST`, `PATCH`, `DELETE`, `OPTIONS`
- **Autenticação**: requerida via `requireUser`.
- **Notas**: escreve o nome do negócio relacionado em `related_deal_name` para evitar joins no frontend.

#### `GET /api/tasks`

- **Descrição**: Lista tarefas, unindo negócio (`deals`) e responsável (`profiles`). Resultado normalizado por `mapTaskRecord`.
- **Resposta 200**: `Array<Task>` com `id`, `title`, `dueDate`, `priority`, `status`, `description`, `relatedDealId`, `relatedDealName`, `googleCalendarEventId`, `createdAt`.

#### `POST /api/tasks`

- **Descrição**: Cria tarefa; `title` obrigatório.
- **Payload**: `dueDate`, `priority`, `status`, `description`, `relatedDealId`, `assigneeId`, `googleCalendarEventId`. Se `relatedDealId` for enviado, o backend resolve o `relatedDealName` consultando `deals`.
- **Resposta 201**: tarefa criada com mapeamento consistente ao `GET`.
- **Erros**: `400` ausência de `title`; `401` auth; `500` falhas Supabase.

#### `PATCH /api/tasks?id=<uuid>`

- **Descrição**: Atualiza campos pontuais (mesma lógica de mapeamento condicional). Mudança de `relatedDealId` refaz o lookup do nome.
- **Resposta 200**: tarefa atualizada.
- **Erros**: `400` ID inválido; `404` sem correspondência; `401` auth.

#### `DELETE /api/tasks?id=<uuid>`

- **Descrição**: Remove tarefa pelo ID.
- **Resposta 204** se sucesso.
- **Erros**: `400` ID inválido; `404` registro ausente; `401` auth.

### `/api/team`

- **Métodos**: `GET`, `POST`, `PATCH`, `DELETE`, `OPTIONS`
- **Autenticação**: obrigatória; apenas perfis com `user_metadata.role === 'Admin'` podem criar/alterar/apagar membros.

#### `GET /api/team`

- **Descrição**: Retorna perfis da tabela `profiles` com colunas principais. Não exige papel Admin além da autenticação básica.
- **Resposta 200**: `Array<Member>` com `id`, `name`, `email`, `role`, `status`, `lastLogin`, `emailUsageGB`.

#### `POST /api/team`

- **Descrição**: Cria perfil administrativo. Campos obrigatórios `name` e `email`.
- **Payload**: aceita `role`, `status`, `emailUsageGB`, `lastLogin`.
- **Resposta 201**: membro criado.
- **Erros**: `400` faltando `name` ou `email`; `403` usuário autenticado sem papel Admin; `500` Supabase.

#### `PATCH /api/team?id=<uuid>`

- **Descrição**: Atualiza dados do membro. SOMENTE Admin.
- **Campos aceitos**: `name`, `role`, `status`, `emailUsageGB`, `lastLogin`.
- **Resposta 200**: membro atualizado.
- **Erros**: `400` ID inválido; `404` inexistente; `403` permissão insuficiente.

#### `DELETE /api/team?id=<uuid>`

- **Descrição**: Remove perfil por ID. SOMENTE Admin.
- **Resposta 204** em caso de sucesso.
- **Erros**: `400` ID inválido; `404` registro inexistente; `403` permissão insuficiente.

### `/api/dashboard-data`

- **Métodos**: `GET`, `OPTIONS`
- **Autenticação**: não exige token; rota é usada em dashboards públicos do app.
- **Descrição**: Agrega dados de `deals` e `tasks` para compor cards, gráficos e atividades recentes do painel principal.
- **Resposta 200**:
  - `statCardsData`: lista com título/valor/variação (ex.: receita total formatada em BRL).
  - `salesChartData`: séries mensais (`name`, `sales`, `revenue`).
  - `dealStageData`: contagem por estágio com cor sugerida.
  - `recentActivities`: últimas interações sintetizadas.
  - `insightsHtml`: HTML opcional gerado pelo `generateAutomatedReport` do Gemini quando `GEMINI_API_KEY` está configurada (falhas não quebram a resposta, apenas logam warning).
- **Erros**: `500` se consultas ao Supabase falharem.

### `/api/analytics-data`

- **Métodos**: `GET`, `OPTIONS`
- **Autenticação**: pública (mesmo padrão do dashboard).
- **Descrição**: Endpoint avançado de analytics com previsões de churn e oportunidades de upsell.
- **Resposta 200**:
  - `report`: título, resumo textual e `generatedAt`.
  - `churnPredictions`: top 5 clientes `Closed Won` com `churnRisk`, `primaryReason`, `suggestedAction`.
  - `upsellOpportunities`: top 5 potenciais upsell com `confidence` e `potentialValue` estimado.
  - `salesData`, `dealData`: agregados semelhantes ao dashboard.
  - `insightsHtml`: HTML opcional via Gemini.
- **Erros**: `500` em falhas de leitura Supabase; erros Gemini apenas geram log.

### `/api/compliance`

- **Métodos**: `GET`, `OPTIONS`
- **Autenticação**: pública.
- **Descrição**: Consolida status de consentimento e logs de acesso (tarefas/deals) para fins de LGPD.
- **Resposta 200**:
  - `consentStatus`: total de usuários, quantos estão ativos (interpretação de consentimento) e texto padrão.
  - `accessLogs`: até 60 eventos recentes com `id`, `user`, `action`, `target`, `timestamp` formatado para `pt-BR`.
- **Erros**: `500` caso alguma consulta falhe.

### `/api/indicacoes`

- **Métodos**: `GET`, `OPTIONS`
- **Autenticação**: pública.
- **Descrição**: Endpoint multifuncional controlado por `section`.

#### `GET /api/indicacoes?section=status`

- **Comportamento**: padrão quando `section` ausente ou inválida. Calcula nível atual do programa de indicações usando dados da tabela `indicacoes` (convênios convertidos e recompensa total).
- **Resposta 200**: objeto com `nivel`, `total_ganho`, `indicacoes_convertidas`, `meta_proximo_nivel`, `beneficio_atual`.

#### `GET /api/indicacoes?section=minhas`

- **Comportamento**: lista indicações registradas (`id`, `empresa_nome`, `status`, `data_indicacao`, `recompensa_ganha`).
- **Resposta 200**: array ordenado desc por `data_indicacao`.

#### `GET /api/indicacoes?section=sugestoes&cep=01001000`

- **Comportamento**: retorna até 20 empresas ativas sugeridas, com cálculo opcional de distância usando BrasilAPI CEP. Inclui recompensa sugerida conforme porte.
- **Resposta 200**: lista de empresas em formato `mapEmpresaRecord`, acrescida de `distancia_km` (quando CEP válido e empresas com lat/long) e `recompensa` estimada.
- **Erros**: `500` falha Supabase; logs warn quando CEP não retorna coordenadas.

### `/api/reports`

- **Métodos**: `GET`, `OPTIONS`
- **Autenticação**: pública.
- **Param obrigatório**: `type` (`network`, `territorial`, `performance`); ausente equivale a `network`.

#### `GET /api/reports?type=network`

- **Descrição**: Monta mapa de vínculos entre sócios e empresas a partir de `empresa_socios`, agregando por CPF parcial.
- **Resposta 200**: `{ "networkData": Array<{ socio_nome, vinculos[] }> }`, onde cada vínculo carrega `empresa_vinculada_cnpj`, `empresa_vinculada_nome`, `grau_vinculo` e `tipo_vinculo`.

#### `GET /api/reports?type=territorial`

- **Descrição**: Exporta empresas ativas com dados cadastrais completos para análise territorial.
- **Resposta 200**: `{ "territorialData": Array<EmpresaResumida> }` seguindo formato `mapEmpresaRecord`.

#### `GET /api/reports?type=performance`

- **Descrição**: Reutiliza mesma lógica de gamificação do endpoint de indicações para gerar resumo de performance e listar indicações.
- **Resposta 200**: `{ "performanceData": { status, indicacoes[] } }`.
- **Erros**: `400` para tipos não reconhecidos; `500` falhas de leitura.

### `/api/cnpj-lookup`

- **Métodos**: `GET`, `POST`, `OPTIONS`
- **Autenticação**: pública.
- **Descrição geral**: Proxy que normaliza dados de CNPJ consultando BrasilAPI, ReceitaWS e, se configurado, CNPJA (`CNPJA_API_KEY`).

#### `GET /api/cnpj-lookup?cnpj=<valor>`

- **Comportamento**: verifica CNPJ em múltiplas fontes até encontrar resposta. Normaliza campos (`endereco_principal`, `cnae_principal`, `quadro_socios`).
- **Resposta 200**: objeto compatível com `mapEmpresaRecord` (sem persistir).
- **Erros**: `400` CNPJ ausente; `500` quando nenhuma API retorna dados.

#### `POST /api/cnpj-lookup`

- **Payload**: `{ "cnpjs": ["11222333000181", ...] }`
- **Comportamento**: itera pelos CNPJs retornando lista `resultados` (sucesso) e `erros`, com delay de 1 segundo entre chamadas para mitigar rate limit.
- **Resposta 200**: objeto com `total`, `sucessos`, `erros`, `resultados[]`, `erros[]`.
- **Erros**: `400` lista inválida; `500` exceções não tratadas.


